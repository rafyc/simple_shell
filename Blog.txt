---

What happens when youÂ ()
type ls *.c in shell
We merge in this simple article, our previous knowledge of the shell with the specifics of how it works under the hoods (including syscalls).
Concept
The Thompson shell was the first Unix shell (also called "sh").
K.L Thompson is the inventor of the UNIX Operating System programming languageÂ . He wrote in B the first version of Unix in 1970, when he was working at Bell Labs with Dennis Ritchie the inventor of the C Language.
Nowdays, we are using different types of shells on our machine and we can suggest you to start with a first step with the command 'echo $PATH 'Â . You can use echo $PATH to check the $PATH environment variable and see the directories in your path. You will observe how the architecture of Unix works. Type the following and then hit Enter:
echo $PATH 

---

BriefÂ :
Since you can have different types of filesÂ . If you would sayâ€Š-â€Š"heyÂ , software list all my C filesÂ , which are living in this subdirectory or in this directory to do so and soÂ â€¦ you figure out a great thingÂ ! Yes, in fact all you have to do is typing in your terminal a pretty fast and simple command to do that for youÂ :' ls *.c'
ğŸ¤” How come? How does it workÂ ?
-> User interacts with the kernel through system calls
command prompt shows user_name@hostname:$The look of the prompt is stored within the PS1 variable. The system settings of the prompt (for all users on the system) are stored in /etc/bashrc file. $: is the prompt symbol.
Under bash, you can set your prompt by changing the value of the PS1 environment variable and can be made permanent by placing the "export" definition in your ~/.bashrc file. PS1 can contain any amount of plain text that you'd like. They are many tutorials on how To Customize Bash Prompt in Linux on line.

---

Here's what the program does after typing ls *.c in the shellÂ :
Step by step descriptive logic to list all files and directories in the current directory with the command ls *.c
Read the entire line from standard inputÂ , store it into a buffer
Expansion (*) -> replace '.c' with a list of all files in the current directory endind with '.c'
Tokenization = Break the command into unit pieces in array of tokens.
Check for aliases (compare each token to aliases of the system)
Check for built-ins ( check if the command is a pre-defined function /system )
Find the command in the PATH ($PATH is where the programm is searching the executable file)
Call the program ls with all the filename ending withÂ .c as parameters.
When ls is doneÂ , print the prompt using PS1
Wait for a new command to be entered
ref: Mock interview ğŸ¤´ğŸ‘©

---

NOTIONSÂ :
Kernel: Kernel is the heart of the Operating systemÂ , written in C
The Unix kernel is loaded first when the Unix system is booted.
It manages hardware and executing processes.
It controls the allocation & deallocation of memory to processes.
Kernel acts as an intermediate between user and hardware.
It also manages files, data transfer files and memory.
An operating system is a collection of programs that handle all the other programs (i.e, application programs ) in a computer as well as the allocation and use of hardware resources such as the central processing unit (CPU), memory and the hard disk drive (HDD). The UNIX operating system is still the best computer O.S to have been ever developedÂ , is elegant in its simplicity which played an important role in the Great Success of it and its various descendants including LINUX. The Popular shells for interactive use include BashÂ , installed by default on Linux installations.
To understand the use of an interface interpreter (shell)in a UNIX Operating System Linux, we had explained it through the 'ls' command with options listing file attributes ( ls *.c) See alsoÂ : Wildcard.

---

System calls are used for controlling processes. There are various (+1000) systemÂ calls
Examples
read()
fork()
exec()
wait()
write, open, execve, exit, fflush, free, malloc, getline, isatty, perror, strtok, and waitpid.
see alsoÂ : System callâ€Š-â€ŠWikipedia

---

ShellÂ :
Shell acts as an interface between user & a kernel. The most minimalistic and also the most powerful type of user interface is a shellÂ , which as its name implies, is an outer wrapper to the kernel (OS) that enables users to interact with computers in a text-only mode.
GloballyÂ :
Shells are interpreters, they read each command entered by the user (or read from a file), In Our case talking about subprocess (child process) of the parent shell. Steps areÂ : display a promptÂ ; read command; tokenizeÂ ; interpret itÂ ; checkÂ ; process the syntax to execute it and display again prompt(interactive) or exit.
Locally:
When you create a directory in your workspace, it's like to give your files a protectorÂ , a "house" preventing them from errors or bad manipulations (see files permissions) or to use them during a specific programmÂ .
The main idea here is to find your files thanks to the software shell.
The shell is always waiting for a command, as you can see the prompt $Â ; this is done with an infinite loop in the main.cÂ , and asks for text input with the getline functionÂ , when the ls -l command is entered it is stored in the getline buffer.This is shortly what happens when you type this command in the shell as you probably done many timesÂ .
What is read on the shell is sent to the system function which will therefore transfer the command to the real interpreter of the system, unless you type exit in which case the application stops.
To summ up ls *.c command displays all file names ending by ".c"Â , replacing the * symbol with all occurrences of them. Behind this command they are different operations and system calls interactions.
If you are interestedÂ :
Visit Our repository on GitHub

---

See you soon in another article #C_is_fun ğŸ˜
Siham Badyine - Gregoire Coudrin -Raphael Chemouni for Holberton School 
